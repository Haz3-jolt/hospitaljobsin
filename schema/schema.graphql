directive @isAuthenticated on FIELD_DEFINITION

type Account implements Node {
  """The Globally Unique ID of this object"""
  id: ID!
  fullName: String!
  email: String!
  hasOnboarded: Boolean!
  updatedAt: DateTime
  profile: ProfilePayload!
  avatarUrl: String!
  organizations(before: ID = null, after: ID = null, first: Int = null, last: Int = null): OrganizationConnection!
  sessions(before: ID = null, after: ID = null, first: Int = null, last: Int = null): SessionConnection!
  webauthnCredentials(before: ID = null, after: ID = null, first: Int = null, last: Int = null): WebAuthnCredentialConnection!
}

type AccountNotFoundError implements Error {
  message: String!
}

type Address {
  line1: String
  line2: String
  city: String
  state: String
  country: String
  pincode: String
}

input AddressInput {
  line1: String
  line2: String
  city: String
  state: String
  country: String
  pincode: String
}

type CreateOrganizationLogoPresignedURLPayload {
  presignedUrl: String!
}

union CreateOrganizationPayload = Organization | OrganizationSlugInUseError

union CreateWebAuthnCredentialPayload = CreateWebAuthnCredentialSuccess | InvalidPasskeyRegistrationCredentialError

type CreateWebAuthnCredentialSuccess {
  webAuthnCredentialEdge: WebAuthnCredentialEdge!
}

enum Currency {
  INR
}

type CurrentJob {
  currentTitle: String!
  currentOrganization: String
  currentSalary: Float
}

"""Date (isoformat)"""
scalar Date

"""Date with time (isoformat)"""
scalar DateTime

type DeleteOtherSessionsPayload {
  deletedSessionIds: [ID!]!
}

union DeleteSessionPayload = DeleteSessionSuccess | SessionNotFoundError

type DeleteSessionSuccess {
  sessionEdge: SessionEdge!
}

union DeleteWebAuthnCredentialPayload = DeleteWebAuthnCredentialSuccess | WebAuthnCredentialNotFoundError

type DeleteWebAuthnCredentialSuccess {
  webAuthnCredentialEdge: WebAuthnCredentialEdge!
}

type EmailInUseError implements Error {
  message: String!
}

type EmailVerificationTokenCooldownError implements Error {
  message: String!
  remainingSeconds: Int!
}

interface Error {
  message: String!
}

enum GenderType {
  MALE
  FEMALE
  OTHER
}

union GenerateAuthenticationOptionsPayload = GenerateAuthenticationOptionsSuccess | InvalidRecaptchaTokenError

type GenerateAuthenticationOptionsSuccess {
  authenticationOptions: JSON!
}

union GeneratePasskeyCreationOptionsPayload = GeneratePasskeyCreationOptionsSuccess

type GeneratePasskeyCreationOptionsSuccess {
  registrationOptions: JSON!
}

union GeneratePasskeyRegistrationOptionsPayload = GeneratePasskeyRegistrationOptionsSuccess | InvalidRecaptchaTokenError | EmailInUseError

type GeneratePasskeyRegistrationOptionsSuccess {
  registrationOptions: JSON!
}

type InvalidCredentialsError implements Error {
  message: String!
}

type InvalidEmailError implements Error {
  message: String!
}

type InvalidEmailVerificationTokenError implements Error {
  message: String!
}

type InvalidPasskeyAuthenticationCredentialError implements Error {
  message: String!
}

type InvalidPasskeyRegistrationCredentialError implements Error {
  message: String!
}

type InvalidPasswordResetTokenError implements Error {
  message: String!
}

type InvalidRecaptchaTokenError implements Error {
  message: String!
}

type InvalidSignInMethodError implements Error {
  message: String!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](https://ecma-international.org/wp-content/uploads/ECMA-404_2nd_edition_december_2017.pdf).
"""
scalar JSON @specifiedBy(url: "https://ecma-international.org/wp-content/uploads/ECMA-404_2nd_edition_december_2017.pdf")

type Job implements Node {
  """The Globally Unique ID of this object"""
  id: ID!
  title: String!
  slug: String!
  description: String
  category: String!
  type: JobType!
  workMode: WorkMode!
  address: Address!
  application: String!
  skills: [String!]!
  currency: Currency!
  hasSalaryRange: Boolean!
  minSalary: Int
  maxSalary: Int
  hasExperienceRange: Boolean!
  minExperience: Int
  maxExperience: Int
  updatedAt: DateTime!
  expiresAt: DateTime
  createdAt: DateTime!
  isSaved: Boolean!
  organization: Organization
}

type JobConnection {
  pageInfo: PageInfo!
  edges: [JobEdge!]!
}

type JobEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: Job!
}

type JobNotFoundError implements Error {
  message: String!
}

union JobPayload = Job | JobNotFoundError

enum JobType {
  FULL_TIME
  PART_TIME
  INTERNSHIP
  CONTRACT
}

type Language {
  name: String!
  proficiency: String!
}

input LanguageInput {
  name: String!
  proficiency: String!
}

union LoginWithPasskeyPayload = Account | InvalidPasskeyAuthenticationCredentialError | InvalidRecaptchaTokenError | WebAuthnChallengeNotFoundError

union LoginWithPasswordPayload = Account | InvalidCredentialsError | InvalidRecaptchaTokenError | InvalidSignInMethodError

type LogoutPayload {
  message: String!
}

enum MaritalStatusType {
  MARRIED
  SINGLE
}

type Mutation {
  """Request an email verification token."""
  requestEmailVerificationToken(
    """The email to request an email verification token for."""
    email: String!

    """The recaptcha token to verify the user request."""
    recaptchaToken: String!
  ): RequestEmailVerificationTokenPayload!

  """Verify an email."""
  verifyEmail(
    """The email to request an email verification token for."""
    email: String!

    """The email verification token."""
    emailVerificationToken: String!

    """The recaptcha token to verify the user request."""
    recaptchaToken: String!
  ): VerifyEmailPayload!

  """Register a new user with a password."""
  registerWithPassword(
    """The email of the new user."""
    email: String!

    """The email verification token."""
    emailVerificationToken: String!

    """The password of the new user."""
    password: String!

    """The full name of the new user."""
    fullName: String!

    """The recaptcha token to verify the user request."""
    recaptchaToken: String!
  ): RegisterWithPasswordPayload!

  """Generate registration options for registering via a passkey."""
  generatePasskeyRegistrationOptions(
    """The email of the new user."""
    email: String!

    """The full name of the new user."""
    fullName: String!

    """The recaptcha token to verify the user request."""
    recaptchaToken: String!
  ): GeneratePasskeyRegistrationOptionsPayload!

  """Register a new user with a passkey."""
  registerWithPasskey(
    """The email of the new user."""
    email: String!

    """The email verification token."""
    emailVerificationToken: String!

    """The passkey registration response of the new user."""
    passkeyRegistrationResponse: JSON!

    """The full name of the new user."""
    fullName: String!

    """The recaptcha token to verify the user request."""
    recaptchaToken: String!
  ): RegisterWithPasskeyPayload!

  """Generate authentication options."""
  generateAuthenticationOptions(
    """The recaptcha token to verify the user request."""
    recaptchaToken: String!
  ): GenerateAuthenticationOptionsPayload!

  """Log in a user with a passkey."""
  loginWithPasskey(
    """The authentication response of the user."""
    authenticationResponse: JSON!

    """The recaptcha token to verify the user request."""
    recaptchaToken: String!
  ): LoginWithPasskeyPayload!

  """Log in a user with email and password."""
  loginWithPassword(
    """The email of the user."""
    email: String!

    """The password of the user."""
    password: String!

    """The recaptcha token to verify the user request."""
    recaptchaToken: String!
  ): LoginWithPasswordPayload!

  """Log out the current user."""
  logout: LogoutPayload! @isAuthenticated

  """Request a password reset."""
  requestPasswordReset(
    """The email of the existing user."""
    email: String!

    """The recaptcha token to verify the user request."""
    recaptchaToken: String!
  ): RequestPasswordResetPayload!

  """Reset a user's password."""
  resetPassword(
    """The email of the existing user."""
    email: String!

    """The password reset token."""
    passwordResetToken: String!

    """The new password."""
    newPassword: String!
  ): ResetPasswordPayload!

  """Delete other sessions of the viewer than the current one."""
  deleteOtherSessions: DeleteOtherSessionsPayload! @isAuthenticated

  """Delete session by ID."""
  deleteSession(
    """The ID of the session to delete."""
    sessionId: ID!
  ): DeleteSessionPayload! @isAuthenticated

  """Delete webauthn credential by ID."""
  deleteWebAuthnCredential(
    """The ID of the Webauthn credential to delete."""
    webAuthnCredentialId: ID!
  ): DeleteWebAuthnCredentialPayload! @isAuthenticated

  """Delete webauthn credential by ID."""
  updateWebAuthnCredential(
    """The ID of the Webauthn credential to update."""
    webAuthnCredentialId: ID!

    """The nickname of the passkey."""
    nickname: String!
  ): UpdateWebAuthnCredentialPayload! @isAuthenticated

  """Generate registration options for adding a webauthn credential."""
  generateWebAuthnCredentialCreationOptions: GeneratePasskeyCreationOptionsPayload! @isAuthenticated

  """Create a new webauthn credential for the current user."""
  createWebAuthnCredential(
    """The passkey registration response."""
    passkeyRegistrationResponse: JSON!

    """The nickname of the passkey."""
    nickname: String = null
  ): CreateWebAuthnCredentialPayload! @isAuthenticated

  """Save a job."""
  saveJob(
    """The ID of the job to save."""
    jobId: ID!
  ): SaveJobPayload! @isAuthenticated

  """Save a job."""
  unsaveJob(
    """The ID of the job to unsave."""
    jobId: ID!
  ): UnsaveJobPayload! @isAuthenticated

  """Update the current user's profile personal details."""
  updateProfilePersonalDetails(address: AddressInput!, gender: GenderType = null, dateOfBirth: Date = null, maritalStatus: MaritalStatusType = null, category: String = null): UpdateProfilePayload! @isAuthenticated

  """Update the current user's profile languages."""
  updateProfileLanguages(languages: [LanguageInput!]!): UpdateProfilePayload! @isAuthenticated

  """Update the current user's account."""
  updateAccount(fullName: String!): UpdateAccountPayload! @isAuthenticated

  """Create an organization."""
  createOrganization(
    """The full name of the organization."""
    fullName: String!

    """The slug of the organization."""
    slug: String!

    """The website of the organization."""
    website: String = null

    """The description of the organization."""
    description: String = null
  ): CreateOrganizationPayload! @isAuthenticated

  """Create an organization logo presigned URL."""
  createOrganizationLogoPresignedUrl: CreateOrganizationLogoPresignedURLPayload! @isAuthenticated
}

"""An object with a Globally Unique ID"""
interface Node {
  """The Globally Unique ID of this object"""
  id: ID!
}

type NotAuthenticatedError implements Error {
  message: String!
}

type Organization implements Node {
  """The Globally Unique ID of this object"""
  id: ID!
  name: String!
  slug: String!
  description: String
  address: Address!
  email: String
  website: String
  logoUrl: String!
  isAdmin: Boolean!
  isMember: Boolean!
  jobs(before: ID = null, after: ID = null, first: Int = null, last: Int = null): JobConnection!
  members(before: ID = null, after: ID = null, first: Int = null, last: Int = null): OrganizationMemberConnection!
}

type OrganizationConnection {
  pageInfo: PageInfo!
  edges: [OrganizationEdge!]!
}

type OrganizationEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: Organization!
}

type OrganizationMemberConnection {
  pageInfo: PageInfo!
  edges: [OrganizationMemberEdge!]!
}

type OrganizationMemberEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: Account!
  role: String!
  createdAt: DateTime!
}

type OrganizationNotFoundError implements Error {
  message: String!
}

union OrganizationPayload = Organization | OrganizationNotFoundError

type OrganizationSlugInUseError implements Error {
  message: String!
}

"""Information to aid in pagination."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

type PasswordNotStrongError implements Error {
  message: String!
}

type PasswordResetToken implements Node {
  """The Globally Unique ID of this object"""
  id: ID!
  email: String!
}

type PasswordResetTokenNotFoundError implements Error {
  message: String!
}

union PasswordResetTokenPayload = PasswordResetToken | PasswordResetTokenNotFoundError

type Profile implements Node {
  """The Globally Unique ID of this object"""
  id: ID!
  gender: GenderType
  dateOfBirth: Date
  address: Address!
  maritalStatus: MaritalStatusType
  category: String
  languages: [Language!]!
  totalJobExperience: Float
  currentJob: CurrentJob
  createdAt: DateTime!
}

type ProfileNotFoundError implements Error {
  message: String!
}

union ProfilePayload = Profile | ProfileNotFoundError

type Query {
  """Get the current user."""
  viewer: ViewerPayload!

  """Geta password reset token."""
  passwordResetToken(
    """Generated password reset token"""
    resetToken: String!

    """The email the password reset token belongs to."""
    email: String!
  ): PasswordResetTokenPayload!
  node(
    """The ID of the object."""
    id: ID!
  ): Node

  """Get all jobs available."""
  jobs(
    """Search term"""
    searchTerm: String = null
    before: ID = null
    after: ID = null
    first: Int = null
    last: Int = null
  ): JobConnection!

  """Get job by ID."""
  job(
    """Slug of the job"""
    slug: String!
  ): JobPayload!
  savedJobs(before: ID = null, after: ID = null, first: Int = null, last: Int = null): SavedJobConnection! @isAuthenticated

  """Get organization by slug."""
  organization(
    """Slug of the organization"""
    slug: String!
  ): OrganizationPayload!
}

union RegisterWithPasskeyPayload = Account | EmailInUseError | InvalidEmailVerificationTokenError | InvalidRecaptchaTokenError | InvalidPasskeyRegistrationCredentialError

union RegisterWithPasswordPayload = Account | EmailInUseError | InvalidEmailVerificationTokenError | InvalidRecaptchaTokenError | PasswordNotStrongError

type RequestEmailVerificationSuccess {
  message: String!
  remainingSeconds: Int!
}

union RequestEmailVerificationTokenPayload = RequestEmailVerificationSuccess | EmailInUseError | EmailVerificationTokenCooldownError | InvalidRecaptchaTokenError | InvalidEmailError

union RequestPasswordResetPayload = RequestPasswordResetSuccess | InvalidRecaptchaTokenError

type RequestPasswordResetSuccess {
  message: String!
}

union ResetPasswordPayload = Account | InvalidPasswordResetTokenError | PasswordNotStrongError

union SaveJobPayload = SaveJobResult | JobNotFoundError

type SaveJobResult {
  savedJobEdge: SavedJobEdge!
}

type SavedJobConnection {
  pageInfo: PageInfo!
  edges: [SavedJobEdge!]!
}

type SavedJobEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: Job!
  savedAt: DateTime!
}

type SavedJobNotFoundError implements Error {
  message: String!
}

type Session implements Node {
  """The Globally Unique ID of this object"""
  id: ID!
  userAgent: String!
  ipAddress: String!
  createdAt: DateTime!
  isCurrentSession: Boolean!
}

type SessionConnection {
  pageInfo: PageInfo!
  edges: [SessionEdge!]!
}

type SessionEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: Session!
}

type SessionNotFoundError implements Error {
  message: String!
}

union UnsaveJobPayload = UnsaveJobResult | SavedJobNotFoundError

type UnsaveJobResult {
  savedJobEdge: SavedJobEdge!
}

union UpdateAccountPayload = Account | AccountNotFoundError

union UpdateProfilePayload = Account

union UpdateWebAuthnCredentialPayload = WebAuthnCredential | WebAuthnCredentialNotFoundError

union VerifyEmailPayload = VerifyEmailSuccess | InvalidRecaptchaTokenError | InvalidEmailVerificationTokenError | EmailInUseError

type VerifyEmailSuccess {
  message: String!
}

union ViewerPayload = Account | NotAuthenticatedError

type WebAuthnChallengeNotFoundError implements Error {
  message: String!
}

type WebAuthnCredential implements Node {
  """The Globally Unique ID of this object"""
  id: ID!
  nickname: String!
  createdAt: DateTime!
}

type WebAuthnCredentialConnection {
  pageInfo: PageInfo!
  edges: [WebAuthnCredentialEdge!]!
}

type WebAuthnCredentialEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: WebAuthnCredential!
}

type WebAuthnCredentialNotFoundError implements Error {
  message: String!
}

enum WorkMode {
  REMOTE
  HYBRID
  OFFICE
}
